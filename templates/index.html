<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Watch Party - Debug Build</title>
<script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
<style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            text-align: center;
            color: white;
            backdrop-filter: blur(10px);
        }

        .header h1 {
            font-size: 2em;
            margin-bottom: 5px;
        }

        .header p {
            opacity: 0.9;
        }

        .main-container {
            display: flex;
            flex: 1;
            padding: 20px;
            gap: 20px;
            max-width: 1800px;
            margin: 0 auto;
            width: 100%;
        }

        .video-section {
            flex: 2;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .movie-player {
            background: #000;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .movie-player video {
            width: 100%;
            display: block;
            max-height: 500px;
        }

        .player-controls {
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .video-chat-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }

        .video-chat-box {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            overflow: hidden;
            position: relative;
            aspect-ratio: 4/3;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }

        .video-chat-box video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .video-label {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
        }

        .sidebar {
            flex: 1;
            min-width: 300px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .debug {
            background: #fff;
            border-radius: 10px;
            padding: 12px;
            max-height: 600px;
            overflow: auto;
            font-family: monospace;
            font-size: 11px;
        }

        .controls {
            display: flex;
            gap: 8px;
            margin-top: 8px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 16px;
            background: #667eea;
            color: #fff;
            border-radius: 6px;
            cursor: pointer;
            border: none;
            font-size: 14px;
        }

        .btn.warn {
            background: #dc3545;
        }
        
        .btn.orange {
            background: #ff9800;
        }

        .input {
            padding: 10px;
            border-radius: 6px;
            border: 2px solid rgba(102, 126, 234, 0.3);
            font-size: 14px;
        }
    </style>
</head>
<body>
<div class="header">
  <h1>üé¨ Watch Party ‚Äî Debug Build</h1>
  <p>Use two browsers/devices. Watch the log panel for events.</p>
</div>

<div class="main-container">
  <div class="video-section">
    <div class="movie-player">
      <video id="moviePlayer" controls crossorigin="anonymous"></video>
      <div style="padding:12px; display:flex; gap:10px; flex-wrap:wrap; background:rgba(0,0,0,0.9);">
        <button class="btn" onclick="syncPlay()">‚ñ∂ Sync Play</button>
        <button class="btn" onclick="syncPause()">‚è∏ Sync Pause</button>
        <input id="videoUrl" class="input" style="flex:1; min-width:200px;" placeholder="Enter direct .mp4 URL" />
        <button class="btn" onclick="loadVideo()">Load URL</button>
      </div>
    </div>

    <div class="video-chat-container">
      <div class="video-chat-box">
        <video id="localVideo" autoplay muted playsinline></video>
        <div class="video-label">You</div>
      </div>
      <div class="video-chat-box">
        <video id="remoteVideo" autoplay playsinline></video>
        <div id="remotePlaceholder" style="position:absolute; inset:0; display:flex; align-items:center; justify-content:center; font-size:48px; color:#fff;">üë§</div>
        <div class="video-label">Friend</div>
      </div>
    </div>

    <div style="margin-top:12px;">
      <div class="controls">
        <input id="username" class="input" placeholder="Your Name" style="width:150px;" />
        <input id="roomCode" class="input" placeholder="Room code (optional)" style="width:150px;" />
        <button class="btn" onclick="joinRoom()">Join/Create Room</button>
        <button class="btn" id="startCameraBtn" onclick="startCamera()" style="display:none">Start Camera & Mic</button>
        <button class="btn warn" id="stopCameraBtn" onclick="stopCamera()" style="display:none">Stop Camera & Mic</button>
        <button class="btn orange" onclick="forceRenegotiate()">üîÑ Reconnect</button>
      </div>
    </div>
  </div>

  <div class="sidebar">
    <div class="debug" id="debugLog"></div>
    <div style="margin-top:8px;">
      <button class="btn" onclick="downloadLogs()" style="width:100%">Download Logs</button>
    </div>
  </div>
</div>

<script>
/* ---------- DEBUG LOG HELPERS ---------- */
const logBuf = [];
function dbg(...args) {
  const s = '[' + new Date().toLocaleTimeString() + '] ' + args.map(a => (typeof a === 'object' ? JSON.stringify(a) : String(a))).join(' ');
  logBuf.push(s);
  const el = document.getElementById('debugLog');
  if (el) el.innerText = logBuf.slice(-300).join('\n');
  console.log(...args);
}
function downloadLogs() {
  const blob = new Blob([logBuf.join('\n')], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'watchparty-logs-' + Date.now() + '.txt';
  a.click();
  URL.revokeObjectURL(url);
}

/* ---------- SOCKET & WEBRTC GLOBALS ---------- */
let socket = null;
let localStream = null;
let peerConnection = null;
let remoteStream = null;
let username = 'User';
let currentRoom = null;
let remoteSid = null;
let reconnectAttempts = 0;
let reconnectTimer = null;

/* Negotiation helpers */
let makingOffer = false;
let polite = false;
const pendingIceCandidates = [];
const configuration = {
  iceServers: [
    { urls: 'stun:stun.l.google.com:19302' },
    { urls: 'stun:stun1.l.google.com:19302' },
    { urls: 'stun:stun2.l.google.com:19302' },
    { urls: 'turn:openrelay.metered.ca:80', username: 'openrelayproject', credential: 'openrelayproject' },
    { urls: 'turn:openrelay.metered.ca:443', username: 'openrelayproject', credential: 'openrelayproject' },
    { urls: 'turn:openrelay.metered.ca:443?transport=tcp', username: 'openrelayproject', credential: 'openrelayproject' }
  ],
  iceCandidatePoolSize: 10
};

/* ---------- SOCKET INIT ---------- */
function initSocket() {
  if (typeof io === 'undefined') {
    dbg('Socket.IO not loaded');
    return;
  }
  dbg('initSocket...');
  socket = io();

  socket.on('connect', () => {
    dbg('socket connect id=', socket.id);
    addSystemMessage('‚úì Connected to server: ' + socket.id);
  });

  socket.on('disconnect', () => {
    dbg('socket disconnect');
    addSystemMessage('‚úó Disconnected from server');
  });

  socket.on('connected', (d) => { dbg('server connected event', d); });

  socket.on('room_joined', (data) => {
    dbg('room_joined', data);
    currentRoom = data.room_code;
    addSystemMessage('‚úì Joined room: ' + currentRoom);
    document.getElementById('startCameraBtn').style.display = 'inline-block';
  });

  // When a user joins - server broadcasts
  socket.on('user_joined', (data) => {
    dbg('user_joined', data);
    // ignore our own join notification
    if (socket && socket.id && data.sid === socket.id) {
      dbg('ignored user_joined for ourselves');
      return;
    }
    remoteSid = data.sid;
    addSystemMessage(`${data.username} joined the room`);
    // If both sides have local streams, attempt connection
    if (localStream && localStream.getTracks().length) {
      dbg('local stream present - will createPeerConnection to', remoteSid);
      setTimeout(()=> createPeerConnection(remoteSid), 800);
    } else {
      addSystemMessage('‚ö† Start camera to connect video');
    }
  });

  socket.on('user_left', (data) => {
    dbg('user_left', data);
    addSystemMessage('User left the room');
    cleanupPeer();
  });

  socket.on('chat_message', (d) => dbg('chat_message', d));
  socket.on('video_play', (d) => { 
    try { 
      const p = document.getElementById('moviePlayer'); 
      if(typeof d.time === 'number') p.currentTime = d.time; 
      p.play().catch(e=>dbg('autoplay blocked', e)); 
      addSystemMessage('‚ñ∂ Synced play');
    } catch(e){dbg(e)}
  });
  socket.on('video_pause', (d) => { 
    try { 
      const p = document.getElementById('moviePlayer'); 
      if(typeof d.time === 'number') p.currentTime = d.time; 
      p.pause(); 
      addSystemMessage('‚è∏ Synced pause');
    } catch(e){dbg(e)}
  });
  socket.on('video_load', (d) => { 
    const p = document.getElementById('moviePlayer'); 
    p.src = d.url; 
    p.load(); 
    addSystemMessage('Video loaded by ' + (d.username || 'someone')); 
    dbg('video_load', d); 
  });

  // WebRTC signaling
  socket.on('webrtc_offer', async (data) => {
    dbg('webrtc_offer recv from', data && data.sender_sid);
    try {
      const sender = data.sender_sid;
      if (!sender) { dbg('offer has no sender'); return; }
      
      // Set politeness
      polite = socket.id > sender;
      const offerCollision = makingOffer || (peerConnection && peerConnection.signalingState !== 'stable');
      const shouldIgnore = !polite && offerCollision;
      
      if (shouldIgnore) {
        dbg('ignoring offer due to collision (impolite)', {polite, offerCollision});
        return;
      }
      
      // Create pc if missing
      if (!peerConnection) await createPeerConnection(sender);
      
      await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
      dbg('set remote desc from offer');
      
      const answer = await peerConnection.createAnswer();
      await peerConnection.setLocalDescription(answer);
      dbg('created and set local answer');
      
      socket.emit('webrtc_answer', { 
        room_code: currentRoom, 
        target_sid: sender, 
        answer: peerConnection.localDescription, 
        sender_sid: socket.id 
      });
      dbg('sent answer to', sender);
    } catch (err) {
      dbg('error handling offer', err);
    }
  });

  socket.on('webrtc_answer', async (data) => {
    dbg('webrtc_answer recv from', data && data.sender_sid);
    try {
      if (!peerConnection) { dbg('no pc for answer'); return; }
      if (peerConnection.signalingState === 'stable') {
        dbg('already stable, ignoring answer');
        return;
      }
      await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
      dbg('set remote desc from answer');
    } catch (err) {
      dbg('error handling answer', err);
    }
  });

  socket.on('webrtc_ice_candidate', async (data) => {
    try {
      if (!data || !data.candidate) return;
      if (peerConnection && peerConnection.remoteDescription) {
        await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
        dbg('added ICE candidate');
      } else {
        pendingIceCandidates.push(data.candidate);
        dbg('queued ICE candidate (no remote desc yet)');
      }
    } catch (err) {
      dbg('error adding ICE candidate', err);
    }
  });
}

/* ---------- CREATE / MANAGE PEER ---------- */
async function createPeerConnection(targetSid) {
  try {
    dbg('createPeerConnection ->', targetSid);
    
    // Close existing if any
    if (peerConnection) {
      dbg('closing existing peerConnection', peerConnection.connectionState);
      peerConnection.close();
      peerConnection = null;
    }
    
    peerConnection = new RTCPeerConnection(configuration);
    reconnectAttempts = 0; // Reset on new connection

    // Set up remote stream
    if (!remoteStream) remoteStream = new MediaStream();
    const remoteVideo = document.getElementById('remoteVideo');
    remoteVideo.srcObject = remoteStream;
    remoteVideo.muted = false;

    // Add local tracks
    if (localStream) {
      localStream.getTracks().forEach(track => {
        try { 
          dbg('addTrack', track.kind); 
          peerConnection.addTrack(track, localStream); 
        } catch(e){
          dbg('addTrack failed', e);
        }
      });
    }

    peerConnection.ontrack = (ev) => {
      dbg('ontrack', ev.track.kind, 'streams:', ev.streams.length);
      if (ev.streams && ev.streams.length) {
        ev.streams.forEach(s => s.getTracks().forEach(t => {
          try { 
            if (!remoteStream.getTracks().find(track => track.id === t.id)) {
              remoteStream.addTrack(t); 
              dbg('added remote track:', t.kind);
            }
          } catch(e){
            dbg('error adding remote track', e);
          }
        }));
      } else if (ev.track) {
        try { 
          if (!remoteStream.getTracks().find(track => track.id === ev.track.id)) {
            remoteStream.addTrack(ev.track); 
            dbg('added remote track:', ev.track.kind);
          }
        } catch(e){}
      }
      document.getElementById('remotePlaceholder').style.display = 'none';
      addSystemMessage('‚úì Receiving friend\'s ' + ev.track.kind);
    };

    peerConnection.onicecandidate = (ev) => {
      if (ev.candidate) {
        socket.emit('webrtc_ice_candidate', { 
          room_code: currentRoom, 
          target_sid: targetSid, 
          candidate: ev.candidate, 
          sender_sid: socket.id 
        });
      }
    };

    peerConnection.onnegotiationneeded = async () => {
      dbg('onnegotiationneeded triggered');
      try {
        makingOffer = true;
        // Tie-break: only lower socket.id creates offer
        if (!(socket.id && targetSid && (socket.id < targetSid))) {
          dbg('not initiator; skipping offer creation');
          makingOffer = false;
          return;
        }
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        dbg('sending offer to', targetSid);
        socket.emit('webrtc_offer', { 
          room_code: currentRoom, 
          target_sid: targetSid, 
          offer: peerConnection.localDescription, 
          sender_sid: socket.id 
        });
      } catch (err) {
        dbg('negotiation error', err);
      } finally {
        makingOffer = false;
      }
    };

    peerConnection.onconnectionstatechange = () => {
      const state = peerConnection.connectionState;
      dbg('pc connectionState:', state);
      
      if (state === 'connected') {
        addSystemMessage('‚úÖ Video call connected!');
        reconnectAttempts = 0;
        if (reconnectTimer) {
          clearTimeout(reconnectTimer);
          reconnectTimer = null;
        }
      } else if (state === 'disconnected') {
        addSystemMessage('‚ö† Connection lost - will try to reconnect...');
        attemptReconnect();
      } else if (state === 'failed') {
        addSystemMessage('‚ùå Connection failed - reconnecting...');
        attemptReconnect();
      } else if (state === 'closed') {
        dbg('connection closed');
      }
    };

    peerConnection.oniceconnectionstatechange = () => {
      dbg('ice connectionState:', peerConnection.iceConnectionState);
    };

    // Drain queued ICE candidates
    while (pendingIceCandidates.length) {
      const c = pendingIceCandidates.shift();
      try { 
        await peerConnection.addIceCandidate(new RTCIceCandidate(c)); 
        dbg('drained queued ICE candidate'); 
      } catch(e){
        dbg('drain candidate error', e);
      }
    }

    dbg('peerConnection ready');
  } catch (err) {
    dbg('createPeerConnection error', err);
  }
}

function attemptReconnect() {
  if (!remoteSid || !localStream || reconnectAttempts >= 5) {
    if (reconnectAttempts >= 5) {
      addSystemMessage('‚ùå Max reconnect attempts reached. Click "üîÑ Reconnect" manually.');
    }
    return;
  }
  
  reconnectAttempts++;
  const delay = Math.min(2000 * reconnectAttempts, 10000); // Progressive backoff
  
  dbg(`Reconnect attempt ${reconnectAttempts} in ${delay}ms`);
  addSystemMessage(`Reconnecting in ${delay/1000}s... (attempt ${reconnectAttempts}/5)`);
  
  if (reconnectTimer) clearTimeout(reconnectTimer);
  reconnectTimer = setTimeout(() => {
    dbg('Executing reconnect');
    forceRenegotiate();
  }, delay);
}

function cleanupPeer() {
  dbg('cleanupPeer running');
  if (peerConnection) {
    try { peerConnection.close(); } catch(e){}
    peerConnection = null;
  }
  if (remoteStream) {
    try { remoteStream.getTracks().forEach(t=>t.stop()); } catch(e){}
    remoteStream = null;
  }
  const rv = document.getElementById('remoteVideo');
  if (rv) rv.srcObject = null;
  document.getElementById('remotePlaceholder').style.display = 'flex';
  if (reconnectTimer) {
    clearTimeout(reconnectTimer);
    reconnectTimer = null;
  }
  reconnectAttempts = 0;
}

/* ---------- CAMERA CONTROL ---------- */
async function startCamera() {
  try {
    dbg('startCamera: requesting camera & mic...');
    localStream = await navigator.mediaDevices.getUserMedia({ 
      video: { width: { ideal: 1280 }, height: { ideal: 720 } }, 
      audio: { 
        echoCancellation: true,
        noiseSuppression: true,
        autoGainControl: true
      } 
    });

    const localVideo = document.getElementById('localVideo');
    if (localVideo) {
      localVideo.srcObject = localStream;
      localVideo.muted = true;
      localVideo.play().catch(e => dbg('localVideo.play failed', e));
    }

    const sc = document.getElementById('startCameraBtn');
    const st = document.getElementById('stopCameraBtn');
    if (sc) sc.style.display = 'none';
    if (st) st.style.display = 'inline-block';

    addSystemMessage('‚úÖ Camera and microphone started!');
    dbg('startCamera: localStream ready, tracks:', localStream.getTracks().map(t => t.kind));

    if (remoteSid) {
      dbg('startCamera: remoteSid exists, will create PC', remoteSid);
      setTimeout(() => createPeerConnection(remoteSid), 1000);
    }

    return true;
  } catch (err) {
    dbg('startCamera error', err);
    alert('Could not access camera/microphone: ' + (err.message || err));
    return false;
  }
}

function stopCamera() {
  try {
    dbg('stopCamera called');
    if (localStream) {
      localStream.getTracks().forEach(track => {
        track.stop();
        dbg('stopped track:', track.kind);
      });
      localStream = null;
    }
    
    const localVideo = document.getElementById('localVideo');
    if (localVideo) localVideo.srcObject = null;
    
    const sc = document.getElementById('startCameraBtn');
    const st = document.getElementById('stopCameraBtn');
    if (sc) sc.style.display = 'inline-block';
    if (st) st.style.display = 'none';
    
    cleanupPeer();
    addSystemMessage('Camera and mic stopped');
  } catch (err) {
    dbg('stopCamera error', err);
  }
}

/* ---------- UI helpers ---------- */
function addSystemMessage(txt) {
  dbg('SYS:', txt);
}

/* ---------- ROOM / CHAT / VIDEO CONTROL ---------- */
function joinRoom() {
  if (!socket || !socket.connected) { 
    alert('Wait for socket to connect'); 
    return; 
  }
  const name = document.getElementById('username').value.trim();
  const rc = (document.getElementById('roomCode').value.trim()) || ('ROOM-'+Math.random().toString(36).slice(2,8).toUpperCase());
  if (!name) { 
    alert('Enter your name'); 
    return; 
  }
  username = name;
  dbg('joining room:', rc);
  socket.emit('join_room', { room_code: rc, username: name });
}

function loadVideo() {
  const url = document.getElementById('videoUrl').value.trim();
  if (!url || !currentRoom) { 
    alert('Enter video URL and join room first'); 
    return; 
  }
  const p = document.getElementById('moviePlayer');
  p.src = url; 
  p.load();
  socket.emit('video_load', { room_code: currentRoom, url: url, username: username });
  addSystemMessage('Video loaded');
}

function syncPlay() {
  if (!currentRoom) { 
    alert('Join a room first'); 
    return; 
  }
  const p = document.getElementById('moviePlayer');
  socket.emit('video_play', { room_code: currentRoom, time: p.currentTime, username });
  try { p.play(); } catch(e) { dbg('play failed', e); }
  addSystemMessage('Synced play');
}

function syncPause() {
  if (!currentRoom) { 
    alert('Join a room first'); 
    return; 
  }
  const p = document.getElementById('moviePlayer');
  socket.emit('video_pause', { room_code: currentRoom, time: p.currentTime, username });
  p.pause();
  addSystemMessage('Synced pause');
}

/* ---------- FORCE RECONNECT ---------- */
async function forceRenegotiate() {
  if (!remoteSid) { 
    dbg('Cannot reconnect - no remote peer'); 
    addSystemMessage('‚ö† No friend to connect to');
    return; 
  }
  if (!localStream || !localStream.getTracks().length) {
    dbg('Cannot reconnect - no local stream');
    addSystemMessage('‚ö† Start camera first!');
    return;
  }
  
  dbg('force reconnect initiated');
  addSystemMessage('üîÑ Reconnecting video...');
  
  // Clean up existing connection
  cleanupPeer();
  
  // Create new connection after short delay
  setTimeout(() => {
    createPeerConnection(remoteSid);
  }, 500);
}

/* ---------- START ---------- */
window.addEventListener('load', () => {
    initSocket();
    addSystemMessage('‚úÖ Ready! Join a room and start camera.');
    
    // Auto-fill random username
    setTimeout(()=>{ 
        const randomName = 'User' + Math.floor(Math.random()*900);
        document.getElementById('username').value = randomName; 
        dbg('Auto-filled username:', randomName);
    }, 300);
});
</script>
</body>
</html>