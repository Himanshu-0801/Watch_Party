<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Watch Party - Debug Build</title>
<script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
<style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            text-align: center;
            color: white;
            backdrop-filter: blur(10px);
        }

        .header h1 {
            font-size: 2em;
            margin-bottom: 5px;
        }

        .header p {
            opacity: 0.9;
        }

        .connection-status {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 12px;
            margin-top: 8px;
            font-weight: bold;
        }

        .connection-status.connected {
            background: #10b981;
            color: white;
        }

        .connection-status.disconnected {
            background: #ef4444;
            color: white;
        }

        .main-container {
            display: flex;
            flex: 1;
            padding: 20px;
            gap: 20px;
            max-width: 1800px;
            margin: 0 auto;
            width: 100%;
        }

        .video-section {
            flex: 2;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .movie-player {
            background: #000;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .movie-player video {
            width: 100%;
            display: block;
            max-height: 500px;
        }

        .video-chat-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }

        .video-chat-box {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            overflow: hidden;
            position: relative;
            aspect-ratio: 4/3;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }

        .video-chat-box video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .video-label {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
        }

        .sidebar {
            flex: 1;
            min-width: 300px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .debug {
            background: #fff;
            border-radius: 10px;
            padding: 12px;
            max-height: 600px;
            overflow: auto;
            font-family: monospace;
            font-size: 11px;
        }

        .controls {
            display: flex;
            gap: 8px;
            margin-top: 8px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 16px;
            background: #667eea;
            color: #fff;
            border-radius: 6px;
            cursor: pointer;
            border: none;
            font-size: 14px;
        }

        .btn:disabled {
            background: #94a3b8;
            cursor: not-allowed;
        }

        .btn.warn {
            background: #dc3545;
        }
        
        .btn.orange {
            background: #ff9800;
        }

        .input {
            padding: 10px;
            border-radius: 6px;
            border: 2px solid rgba(102, 126, 234, 0.3);
            font-size: 14px;
        }
    </style>
</head>
<body>
<div class="header">
  <h1>üé¨ Watch Party ‚Äî Debug Build</h1>
  <p>Use two browsers/devices. Watch the log panel for events.</p>
  <div id="connectionStatus" class="connection-status disconnected">‚óè Disconnected</div>
</div>

<div class="main-container">
  <div class="video-section">
    <div class="movie-player">
      <video id="moviePlayer" controls crossorigin="anonymous"></video>
      <div style="padding:12px; display:flex; gap:10px; flex-wrap:wrap; background:rgba(0,0,0,0.9);">
        <button class="btn" onclick="syncPlay()">‚ñ∂ Sync Play</button>
        <button class="btn" onclick="syncPause()">‚è∏ Sync Pause</button>
        <input id="videoUrl" class="input" style="flex:1; min-width:200px;" placeholder="Enter direct .mp4 URL" />
        <button class="btn" onclick="loadVideo()">Load URL</button>
      </div>
    </div>

    <div class="video-chat-container">
      <div class="video-chat-box">
        <video id="localVideo" autoplay muted playsinline></video>
        <div class="video-label">You</div>
      </div>
      <div class="video-chat-box">
        <video id="remoteVideo" autoplay playsinline></video>
        <div id="remotePlaceholder" style="position:absolute; inset:0; display:flex; align-items:center; justify-content:center; font-size:48px; color:#fff;">üë§</div>
        <div class="video-label">Friend</div>
      </div>
    </div>

    <div style="margin-top:12px;">
      <div class="controls">
        <input id="username" class="input" placeholder="Your Name" style="width:150px;" />
        <input id="roomCode" class="input" placeholder="Room code (optional)" style="width:150px;" />
        <button class="btn" id="joinRoomBtn" onclick="joinRoom()">Join/Create Room</button>
        <button class="btn" id="startCameraBtn" onclick="startCamera()" style="display:none">Start Camera & Mic</button>
        <button class="btn warn" id="stopCameraBtn" onclick="stopCamera()" style="display:none">Stop Camera & Mic</button>
        <button class="btn orange" onclick="forceRenegotiate()">üîÑ Reconnect</button>
      </div>
    </div>
  </div>

  <div class="sidebar">
    <div class="debug" id="debugLog"></div>
    <div style="margin-top:8px;">
      <button class="btn" onclick="downloadLogs()" style="width:100%">Download Logs</button>
    </div>
  </div>
</div>

<script>
/* ---------- DEBUG LOG HELPERS ---------- */
const logBuf = [];
function dbg(...args) {
  const s = '[' + new Date().toLocaleTimeString() + '] ' + args.map(a => (typeof a === 'object' ? JSON.stringify(a) : String(a))).join(' ');
  logBuf.push(s);
  const el = document.getElementById('debugLog');
  if (el) {
    el.innerText = logBuf.slice(-300).join('\n');
    el.scrollTop = el.scrollHeight;
  }
  console.log(...args);
}

function downloadLogs() {
  const blob = new Blob([logBuf.join('\n')], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'watchparty-logs-' + Date.now() + '.txt';
  a.click();
  URL.revokeObjectURL(url);
}

function updateConnectionStatus(connected) {
  const el = document.getElementById('connectionStatus');
  if (el) {
    el.className = 'connection-status ' + (connected ? 'connected' : 'disconnected');
    el.textContent = connected ? '‚óè Connected' : '‚óè Disconnected';
  }
}

/* ---------- SOCKET & WEBRTC GLOBALS ---------- */
let socket = null;
let localStream = null;
let peerConnection = null;
let remoteStream = null;
let username = 'User';
let currentRoom = null;
let remoteSid = null;
let reconnectAttempts = 0;
let reconnectTimer = null;

/* Negotiation helpers */
let makingOffer = false;
let polite = false;
const pendingIceCandidates = [];
const configuration = {
  iceServers: [
    { urls: 'stun:stun.l.google.com:19302' },
    { urls: 'stun:stun1.l.google.com:19302' },
    { urls: 'stun:stun2.l.google.com:19302' },
    { urls: 'turn:openrelay.metered.ca:80', username: 'openrelayproject', credential: 'openrelayproject' },
    { urls: 'turn:openrelay.metered.ca:443', username: 'openrelayproject', credential: 'openrelayproject' },
    { urls: 'turn:openrelay.metered.ca:443?transport=tcp', username: 'openrelayproject', credential: 'openrelayproject' }
  ],
  iceCandidatePoolSize: 10
};

/* ---------- SOCKET INIT ---------- */
function initSocket() {
  if (typeof io === 'undefined') {
    dbg('‚ùå Socket.IO not loaded');
    addSystemMessage('‚ùå Socket.IO library failed to load');
    return;
  }
  
  dbg('üîå Initializing socket connection...');
  
  // Connect to current origin (works for both local and deployed)
  socket = io({
    transports: ['websocket', 'polling'],
    reconnection: true,
    reconnectionDelay: 1000,
    reconnectionDelayMax: 5000,
    reconnectionAttempts: 5
  });

  socket.on('connect', () => {
    dbg('‚úÖ Socket connected! ID:', socket.id);
    addSystemMessage('‚úÖ Connected to server: ' + socket.id);
    updateConnectionStatus(true);
    reconnectAttempts = 0;
  });

  socket.on('disconnect', (reason) => {
    dbg('‚ùå Socket disconnected:', reason);
    addSystemMessage('‚ùå Disconnected: ' + reason);
    updateConnectionStatus(false);
  });

  socket.on('connect_error', (error) => {
    dbg('‚ùå Connection error:', error.message);
    addSystemMessage('‚ùå Connection error: ' + error.message);
    updateConnectionStatus(false);
  });

  socket.on('reconnect_attempt', (attempt) => {
    dbg('üîÑ Reconnection attempt:', attempt);
    addSystemMessage('üîÑ Reconnecting... (attempt ' + attempt + ')');
  });

  socket.on('reconnect', (attempt) => {
    dbg('‚úÖ Reconnected after', attempt, 'attempts');
    addSystemMessage('‚úÖ Reconnected!');
    updateConnectionStatus(true);
  });

  socket.on('connected', (d) => { 
    dbg('üì° Server connected event:', d); 
  });

  socket.on('room_joined', (data) => {
    dbg('üö™ Room joined:', data);
    currentRoom = data.room_code;
    addSystemMessage('‚úÖ Joined room: ' + currentRoom);
    document.getElementById('startCameraBtn').style.display = 'inline-block';
    document.getElementById('joinRoomBtn').disabled = true;
  });

  socket.on('user_joined', (data) => {
    dbg('üëã User joined:', data);
    if (socket && socket.id && data.sid === socket.id) {
      dbg('(Ignored own join notification)');
      return;
    }
    remoteSid = data.sid;
    addSystemMessage(`üëã ${data.username} joined the room`);
    if (localStream && localStream.getTracks().length) {
      dbg('üìπ Local stream ready, creating peer connection...');
      setTimeout(() => createPeerConnection(remoteSid), 800);
    } else {
      addSystemMessage('‚ö†Ô∏è Start camera to connect video');
    }
  });

  socket.on('user_left', (data) => {
    dbg('üëã User left:', data);
    addSystemMessage('üëã User left the room');
    cleanupPeer();
  });

  socket.on('chat_message', (d) => dbg('üí¨ Chat:', d));
  
  socket.on('video_play', (d) => { 
    try { 
      const p = document.getElementById('moviePlayer'); 
      if(typeof d.time === 'number') p.currentTime = d.time; 
      p.play().catch(e => dbg('‚ö†Ô∏è Autoplay blocked:', e)); 
      addSystemMessage('‚ñ∂Ô∏è Video synced (play)');
    } catch(e) { dbg('‚ùå Video play error:', e); }
  });
  
  socket.on('video_pause', (d) => { 
    try { 
      const p = document.getElementById('moviePlayer'); 
      if(typeof d.time === 'number') p.currentTime = d.time; 
      p.pause(); 
      addSystemMessage('‚è∏Ô∏è Video synced (pause)');
    } catch(e) { dbg('‚ùå Video pause error:', e); }
  });
  
  socket.on('video_load', (d) => { 
    const p = document.getElementById('moviePlayer'); 
    p.src = d.url; 
    p.load(); 
    addSystemMessage('üì∫ Video loaded by ' + (d.username || 'someone')); 
    dbg('üì∫ Video load:', d); 
  });

  // WebRTC signaling
  socket.on('webrtc_offer', async (data) => {
    dbg('üì® WebRTC offer received from:', data && data.sender_sid);
    try {
      const sender = data.sender_sid;
      if (!sender) { 
        dbg('‚ùå Offer has no sender'); 
        return; 
      }
      
      polite = socket.id > sender;
      const offerCollision = makingOffer || (peerConnection && peerConnection.signalingState !== 'stable');
      const shouldIgnore = !polite && offerCollision;
      
      if (shouldIgnore) {
        dbg('‚ö†Ô∏è Ignoring offer due to collision (impolite)');
        return;
      }
      
      if (!peerConnection) await createPeerConnection(sender);
      
      await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
      dbg('‚úÖ Set remote description from offer');
      
      const answer = await peerConnection.createAnswer();
      await peerConnection.setLocalDescription(answer);
      dbg('‚úÖ Created answer');
      
      socket.emit('webrtc_answer', { 
        room_code: currentRoom, 
        target_sid: sender, 
        answer: peerConnection.localDescription, 
        sender_sid: socket.id 
      });
      dbg('üì§ Sent answer to:', sender);
    } catch (err) {
      dbg('‚ùå Error handling offer:', err);
    }
  });

  socket.on('webrtc_answer', async (data) => {
    dbg('üì® WebRTC answer received from:', data && data.sender_sid);
    try {
      if (!peerConnection) { 
        dbg('‚ùå No peer connection for answer'); 
        return; 
      }
      if (peerConnection.signalingState === 'stable') {
        dbg('‚ö†Ô∏è Already stable, ignoring answer');
        return;
      }
      await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
      dbg('‚úÖ Set remote description from answer');
    } catch (err) {
      dbg('‚ùå Error handling answer:', err);
    }
  });

  socket.on('webrtc_ice_candidate', async (data) => {
    try {
      if (!data || !data.candidate) return;
      if (peerConnection && peerConnection.remoteDescription) {
        await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
        dbg('‚úÖ Added ICE candidate');
      } else {
        pendingIceCandidates.push(data.candidate);
        dbg('üì¶ Queued ICE candidate');
      }
    } catch (err) {
      dbg('‚ùå Error adding ICE candidate:', err);
    }
  });
}

/* ---------- CREATE / MANAGE PEER ---------- */
async function createPeerConnection(targetSid) {
  try {
    dbg('üîó Creating peer connection to:', targetSid);
    
    if (peerConnection) {
      dbg('‚ö†Ô∏è Closing existing connection');
      peerConnection.close();
      peerConnection = null;
    }
    
    peerConnection = new RTCPeerConnection(configuration);
    reconnectAttempts = 0;

    if (!remoteStream) remoteStream = new MediaStream();
    const remoteVideo = document.getElementById('remoteVideo');
    remoteVideo.srcObject = remoteStream;
    remoteVideo.muted = false;

    if (localStream) {
      localStream.getTracks().forEach(track => {
        try { 
          dbg('‚ûï Adding track:', track.kind); 
          peerConnection.addTrack(track, localStream); 
        } catch(e) {
          dbg('‚ùå Add track failed:', e);
        }
      });
    }

    peerConnection.ontrack = (ev) => {
      dbg('üì• Received track:', ev.track.kind);
      if (ev.streams && ev.streams.length) {
        ev.streams.forEach(s => s.getTracks().forEach(t => {
          try { 
            if (!remoteStream.getTracks().find(track => track.id === t.id)) {
              remoteStream.addTrack(t); 
              dbg('‚úÖ Added remote track:', t.kind);
            }
          } catch(e) {
            dbg('‚ùå Error adding remote track:', e);
          }
        }));
      } else if (ev.track) {
        try { 
          if (!remoteStream.getTracks().find(track => track.id === ev.track.id)) {
            remoteStream.addTrack(ev.track); 
            dbg('‚úÖ Added remote track:', ev.track.kind);
          }
        } catch(e) {}
      }
      document.getElementById('remotePlaceholder').style.display = 'none';
      addSystemMessage('‚úÖ Receiving ' + ev.track.kind);
    };

    peerConnection.onicecandidate = (ev) => {
      if (ev.candidate) {
        socket.emit('webrtc_ice_candidate', { 
          room_code: currentRoom, 
          target_sid: targetSid, 
          candidate: ev.candidate, 
          sender_sid: socket.id 
        });
      }
    };

    peerConnection.onnegotiationneeded = async () => {
      dbg('ü§ù Negotiation needed');
      try {
        makingOffer = true;
        if (!(socket.id && targetSid && (socket.id < targetSid))) {
          dbg('‚ö†Ô∏è Not initiator, skipping offer');
          makingOffer = false;
          return;
        }
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        dbg('üì§ Sending offer to:', targetSid);
        socket.emit('webrtc_offer', { 
          room_code: currentRoom, 
          target_sid: targetSid, 
          offer: peerConnection.localDescription, 
          sender_sid: socket.id 
        });
      } catch (err) {
        dbg('‚ùå Negotiation error:', err);
      } finally {
        makingOffer = false;
      }
    };

    peerConnection.onconnectionstatechange = () => {
      const state = peerConnection.connectionState;
      dbg('üîÑ Connection state:', state);
      
      if (state === 'connected') {
        addSystemMessage('‚úÖ Video call connected!');
        reconnectAttempts = 0;
        if (reconnectTimer) {
          clearTimeout(reconnectTimer);
          reconnectTimer = null;
        }
      } else if (state === 'disconnected') {
        addSystemMessage('‚ö†Ô∏è Connection lost - reconnecting...');
        attemptReconnect();
      } else if (state === 'failed') {
        addSystemMessage('‚ùå Connection failed - reconnecting...');
        attemptReconnect();
      }
    };

    peerConnection.oniceconnectionstatechange = () => {
      dbg('üßä ICE state:', peerConnection.iceConnectionState);
    };

    while (pendingIceCandidates.length) {
      const c = pendingIceCandidates.shift();
      try { 
        await peerConnection.addIceCandidate(new RTCIceCandidate(c)); 
        dbg('‚úÖ Drained queued ICE candidate'); 
      } catch(e) {
        dbg('‚ùå Drain candidate error:', e);
      }
    }

    dbg('‚úÖ Peer connection ready');
  } catch (err) {
    dbg('‚ùå Create peer connection error:', err);
  }
}

function attemptReconnect() {
  if (!remoteSid || !localStream || reconnectAttempts >= 5) {
    if (reconnectAttempts >= 5) {
      addSystemMessage('‚ùå Max reconnect attempts. Click "üîÑ Reconnect".');
    }
    return;
  }
  
  reconnectAttempts++;
  const delay = Math.min(2000 * reconnectAttempts, 10000);
  
  dbg(`üîÑ Reconnect attempt ${reconnectAttempts} in ${delay}ms`);
  addSystemMessage(`Reconnecting in ${delay/1000}s... (${reconnectAttempts}/5)`);
  
  if (reconnectTimer) clearTimeout(reconnectTimer);
  reconnectTimer = setTimeout(() => {
    dbg('üîÑ Executing reconnect');
    forceRenegotiate();
  }, delay);
}

function cleanupPeer() {
  dbg('üßπ Cleaning up peer connection');
  if (peerConnection) {
    try { peerConnection.close(); } catch(e) {}
    peerConnection = null;
  }
  if (remoteStream) {
    try { remoteStream.getTracks().forEach(t => t.stop()); } catch(e) {}
    remoteStream = null;
  }
  const rv = document.getElementById('remoteVideo');
  if (rv) rv.srcObject = null;
  document.getElementById('remotePlaceholder').style.display = 'flex';
  if (reconnectTimer) {
    clearTimeout(reconnectTimer);
    reconnectTimer = null;
  }
  reconnectAttempts = 0;
}

/* ---------- CAMERA CONTROL ---------- */
async function startCamera() {
  try {
    dbg('üìπ Requesting camera & microphone...');
    localStream = await navigator.mediaDevices.getUserMedia({ 
      video: { width: { ideal: 1280 }, height: { ideal: 720 } }, 
      audio: { 
        echoCancellation: true,
        noiseSuppression: true,
        autoGainControl: true
      } 
    });

    const localVideo = document.getElementById('localVideo');
    if (localVideo) {
      localVideo.srcObject = localStream;
      localVideo.muted = true;
      localVideo.play().catch(e => dbg('‚ùå Local video play failed:', e));
    }

    document.getElementById('startCameraBtn').style.display = 'none';
    document.getElementById('stopCameraBtn').style.display = 'inline-block';

    addSystemMessage('‚úÖ Camera and microphone started!');
    dbg('‚úÖ Local stream ready, tracks:', localStream.getTracks().map(t => t.kind).join(', '));

    if (remoteSid) {
      dbg('üìû Remote peer exists, creating connection...');
      setTimeout(() => createPeerConnection(remoteSid), 1000);
    }

    return true;
  } catch (err) {
    dbg('‚ùå Camera error:', err);
    alert('Could not access camera/microphone: ' + (err.message || err));
    return false;
  }
}

function stopCamera() {
  try {
    dbg('üõë Stopping camera');
    if (localStream) {
      localStream.getTracks().forEach(track => {
        track.stop();
        dbg('‚èπÔ∏è Stopped track:', track.kind);
      });
      localStream = null;
    }
    
    const localVideo = document.getElementById('localVideo');
    if (localVideo) localVideo.srcObject = null;
    
    document.getElementById('startCameraBtn').style.display = 'inline-block';
    document.getElementById('stopCameraBtn').style.display = 'none';
    
    cleanupPeer();
    addSystemMessage('üõë Camera and mic stopped');
  } catch (err) {
    dbg('‚ùå Stop camera error:', err);
  }
}

/* ---------- UI helpers ---------- */
function addSystemMessage(txt) {
  dbg('üí¨', txt);
}

/* ---------- ROOM / CHAT / VIDEO CONTROL ---------- */
function joinRoom() {
  if (!socket || !socket.connected) { 
    alert('‚ö†Ô∏è Wait for socket to connect'); 
    return; 
  }
  const name = document.getElementById('username').value.trim();
  const rc = (document.getElementById('roomCode').value.trim()) || ('ROOM-' + Math.random().toString(36).slice(2, 8).toUpperCase());
  if (!name) { 
    alert('‚ö†Ô∏è Enter your name'); 
    return; 
  }
  username = name;
  dbg('üö™ Joining room:', rc, 'as', name);
  socket.emit('join_room', { room_code: rc, username: name });
}

function loadVideo() {
  const url = document.getElementById('videoUrl').value.trim();
  if (!url || !currentRoom) { 
    alert('‚ö†Ô∏è Enter video URL and join room first'); 
    return; 
  }
  const p = document.getElementById('moviePlayer');
  p.src = url; 
  p.load();
  socket.emit('video_load', { room_code: currentRoom, url: url, username: username });
  addSystemMessage('üì∫ Video loaded');
}

function syncPlay() {
  if (!currentRoom) { 
    alert('‚ö†Ô∏è Join a room first'); 
    return; 
  }
  const p = document.getElementById('moviePlayer');
  socket.emit('video_play', { room_code: currentRoom, time: p.currentTime, username });
  try { p.play(); } catch(e) { dbg('‚ùå Play failed:', e); }
  addSystemMessage('‚ñ∂Ô∏è Synced play');
}

function syncPause() {
  if (!currentRoom) { 
    alert('‚ö†Ô∏è Join a room first'); 
    return; 
  }
  const p = document.getElementById('moviePlayer');
  socket.emit('video_pause', { room_code: currentRoom, time: p.currentTime, username });
  p.pause();
  addSystemMessage('‚è∏Ô∏è Synced pause');
}

/* ---------- FORCE RECONNECT ---------- */
async function forceRenegotiate() {
  if (!remoteSid) { 
    dbg('‚ùå Cannot reconnect - no remote peer'); 
    addSystemMessage('‚ö†Ô∏è No friend to connect to');
    return; 
  }
  if (!localStream || !localStream.getTracks().length) {
    dbg('‚ùå Cannot reconnect - no local stream');
    addSystemMessage('‚ö†Ô∏è Start camera first!');
    return;
  }
  
  dbg('üîÑ Force reconnect initiated');
  addSystemMessage('üîÑ Reconnecting video...');
  
  cleanupPeer();
  
  setTimeout(() => {
    createPeerConnection(remoteSid);
  }, 500);
}

/* ---------- START ---------- */
window.addEventListener('load', () => {
    dbg('üöÄ Application starting...');
    initSocket();
    addSystemMessage('‚úÖ Ready! Join a room and start camera.');
    
    setTimeout(() => { 
        const randomName = 'User' + Math.floor(Math.random() * 9000 + 1000);
        document.getElementById('username').value = randomName; 
        dbg('üë§ Auto-filled username:', randomName);
    }, 300);
});
</script>
</body>
</html>